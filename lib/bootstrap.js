// Generated by LiveScript 1.5.0
var ref$, _mk_func, compileCoffeescript, compileLivescript, xpressionToBody, plv8xSql, operatorsSql, _eval, _apply, _require, _mk_json_eval, _mk_json_eval_ls, _boot;
ref$ = require('..'), _mk_func = ref$._mk_func, compileCoffeescript = ref$.compileCoffeescript, compileLivescript = ref$.compileLivescript, xpressionToBody = ref$.xpressionToBody;
ref$ = require('./sql'), plv8xSql = ref$.plv8xSql, operatorsSql = ref$.operatorsSql;
module.exports = function(drop, cascade, done){
  var this$ = this;
  if (typeof drop === 'function') {
    done = drop;
    drop = false;
  }
  return this.query("select version()", function(rows){
    var x$, ref$, _, pg_version, y$, r;
    x$ = this$.conn;
    x$.query(plv8xSql(drop, cascade));
    ref$ = rows[0].version.match(/^PostgreSQL ([\d\.]+)/), _ = ref$[0], pg_version = ref$[1];
    if (pg_version >= '9.1.0') {
      x$.query('SET client_min_messages TO WARNING;\nDO $$ BEGIN\n    CREATE EXTENSION IF NOT EXISTS plv8;\nEXCEPTION WHEN OTHERS THEN END; $$;\nDO $$ BEGIN\n    CREATE EXTENSION IF NOT EXISTS plls;\nEXCEPTION WHEN OTHERS THEN END; $$;');
    } else {
      x$.query('DO $$ BEGIN\n  CREATE FUNCTION plv8_call_handler() RETURNS language_handler AS \'$libdir/plv8\' LANGUAGE C;\n  CREATE FUNCTION plv8_inline_handler(internal) RETURNS void AS \'$libdir/plv8\' LANGUAGE C;\n  CREATE FUNCTION plv8_call_validator(oid) RETURNS void AS \'$libdir/plv8\' LANGUAGE C;\n  CREATE TRUSTED LANGUAGE plv8 HANDLER plv8_call_handler INLINE plv8_inline_handler VALIDATOR plv8_call_validator;\nEXCEPTION WHEN OTHERS THEN END; $$;\nDO $$ BEGIN\n  CREATE FUNCTION plls_call_handler() RETURNS language_handler AS \'$libdir/plv8\' LANGUAGE C;\n  CREATE FUNCTION plls_inline_handler(internal) RETURNS void AS \'$libdir/plv8\' LANGUAGE C;\n  CREATE FUNCTION plls_call_validator(oid) RETURNS void AS \'$libdir/plv8\' LANGUAGE C;\n  CREATE TRUSTED LANGUAGE plls HANDLER plls_call_handler INLINE plls_inline_handler VALIDATOR plls_call_validator;\nEXCEPTION WHEN OTHERS THEN END; $$;');
    }
    if (pg_version < '9.2.0') {
      x$.query("DO $$ BEGIN\n    INSERT INTO pg_catalog.pg_type (SELECT 'json' AS typname,\n            typnamespace , typowner , typlen , typbyval , typtype , typcategory\n            , typispreferred , typisdefined , typdelim , typrelid , typelem ,\n            typarray , typinput , typoutput , typreceive , typsend  , typmodin\n            , typmodout , typanalyze , typalign , typstorage , typnotnull ,\n            typbasetype , typtypmod , typndims , " + (pg_version < '9.1.0' ? '' : 'typcollation ,') + "\n            typdefaultbin , typdefault\n            FROM pg_catalog.pg_type  where typname = 'text');\nEXCEPTION WHEN OTHERS THEN END; $$;");
      x$.query('select oid from pg_catalog.pg_type  where typname = \'json\' and typtype =\'b\';', [], function(err, res){
        var that, ref$;
        if (that = res != null ? (ref$ = res.rows) != null ? ref$[0] : void 8 : void 8) {
          return this$.registerJsonType(that.oid);
        } else {
          throw "json type not found";
        }
      });
    }
    x$.query('DO $$ BEGIN\n  CREATE DOMAIN plv8x.json AS json;\nEXCEPTION WHEN OTHERS THEN END; $$;');
    if (pg_version < '9.2.0') {
      this$.mkUserFunc("plv8x.json row_to_json(anyelement)", ':-> it', function(){});
      this$.mkUserFunc("plv8x.json array_to_json(anyarray)", ':-> it', function(){});
    }
    if (pg_version < '9.3.0') {
      this$.mkUserFunc("plv8x.json to_json(anyelement)", ':-> it', function(){});
    }
    y$ = this$.conn;
    y$.query(_mk_func('plv8x.boot', {}, 'void', _boot));
    y$.query(_mk_func('plv8x.eval', {
      str: 'text'
    }, 'plv8x.json', _eval));
    y$.query(_mk_func('plv8x.apply', {
      str: 'text',
      args: 'plv8x.json'
    }, 'plv8x.json', _apply));
    y$.query(_mk_func('plv8x.json_eval', {
      code: 'text'
    }, 'plv8x.json', _mk_json_eval(0), {
      cascade: true,
      boot: true
    }));
    y$.query(_mk_func('plv8x.json_eval', {
      data: 'plv8x.json',
      code: 'text'
    }, 'plv8x.json', _mk_json_eval(-1), {
      cascade: true,
      boot: true
    }));
    y$.query(_mk_func('plv8x.json_eval', {
      code: 'text',
      data: 'plv8x.json'
    }, 'plv8x.json', _mk_json_eval(1), {
      cascade: true,
      boot: true
    }));
    y$.query(_mk_func('plv8x.json_eval_ls', {
      code: 'text'
    }, 'plv8x.json', _mk_json_eval_ls(0), {
      cascade: true,
      boot: true
    }));
    y$.query(_mk_func('plv8x.json_eval_ls', {
      data: 'plv8x.json',
      code: 'text'
    }, 'plv8x.json', _mk_json_eval_ls(-1), {
      cascade: true,
      boot: true
    }));
    y$.query(_mk_func('plv8x.json_eval_ls', {
      code: 'text',
      data: 'plv8x.json'
    }, 'plv8x.json', _mk_json_eval_ls(1), {
      cascade: true,
      boot: true
    }));
    y$.query(operatorsSql());
    r = y$.query("select plv8x.boot()");
    r.on('end', done);
    return y$;
  });
};
_eval = function(str){
  return eval(str);
};
_apply = function(func, args){
  func = "(function() {return (" + func + ");})()";
  return eval(func).apply(null, args);
};
_require = function(name){
  var exclude, res, x, err, i$, len$, ref$, code, bundle, loader, that, e;
  plv8.elog(DEBUG, 'require', name, JSON.stringify({
    requireStack: plv8x.requireStack,
    global: plv8x.global
  }));
  if (plv8x.global[name] != null) {
    return plv8x.global[name];
  }
  exclude = plv8x.requireStack.length ? "where name not in (" + plv8x.requireStack.map(function(it){
    return "'" + it + "'";
  }).join(',') + ")" : "";
  res = plv8.execute("select name, code from plv8x.code " + exclude, []);
  x = {};
  err = '';
  for (i$ = 0, len$ = res.length; i$ < len$; ++i$) {
    ref$ = res[i$], code = ref$.code, bundle = ref$.name;
    plv8x.requireStack.push(bundle);
    try {
      loader = "(function() {\n    var module = {exports: {}};\n    var global = {};\n    var require = function(name) {\n      if (name === '" + name + "') {\n        throw new Error('Cannot find module \"" + name + "\"');\n      }\n      return plv8x.require(name);\n    };\n    (function() { " + code + " }).apply(global);\n    if (module.exports.require)\n      return module.exports.require('" + name + "');\n    else\n      return global['" + name + "']\n\n})()";
      if (that = eval(loader)) {
        plv8x.requireStack.pop();
        return plv8x.global[name] = that;
      }
    } catch (e$) {
      e = e$;
      err = e;
      if (!/Cannot find module/.test(e)) {
        plv8x.requireStack = [];
        break;
      }
    }
    plv8x.requireStack.pop();
  }
  plv8.elog(WARNING, "failed to load module " + name + ": " + err);
  if (err.stack) {
    return plv8.elog(WARNING, (ref$ = err.stack) != null ? ref$.substr(0, 235) : void 8);
  }
};
_mk_json_eval = function(type){
  var ref$, this$ = this;
  type == null && (type = 1);
  switch (ref$ = [type], false) {
  case !(function(it){
    return it > 0;
  })(ref$[0]):
    return function(code, data){
      return eval(plv8x.xpressionToBody(code)).apply(data);
    };
  case !(function(it){
      return it < 0;
    })(ref$[0]):
    return function(data, code){
      return eval(plv8x.xpressionToBody(code)).apply(data);
    };
  default:
    return function(code){
      return eval(plv8x.xpressionToBody(code)).apply(this);
    };
  }
};
_mk_json_eval_ls = function(type){
  var ref$, this$ = this;
  type == null && (type = 1);
  switch (ref$ = [type], false) {
  case !(function(it){
    return it > 0;
  })(ref$[0]):
    return function(code, data){
      return eval(plv8x.xpressionToBody("~>" + code)).apply(data);
    };
  case !(function(it){
      return it < 0;
    })(ref$[0]):
    return function(data, code){
      return eval(plv8x.xpressionToBody("~>" + code)).apply(data);
    };
  default:
    return function(code){
      return eval(plv8x.xpressionToBody("~>" + code)).apply(this);
    };
  }
};
_boot = "function() {\n  if (typeof plv8x == 'undefined')\n    plv8x = {\n      require: " + _require.toString().replace(/(['\\])/g, '$1') + ",\n      xpressionToBody: " + xpressionToBody.toString().replace(/(['\\])/g, '$1') + ",\n      compileCoffeescript: " + compileCoffeescript.toString().replace(/(['\\])/g, '$1') + ",\n      compileLivescript: " + compileLivescript.toString().replace(/(['\\])/g, '$1') + ",\n      requireStack: [],\n      global: {}\n    };\n    plv8x_require = require = plv8x.require;\n}";